[TOC]

# pg 备份和恢复

​	数据都是有价值的(生产数据)，postgresql数据库应当定期的备份，虽然过程较为简单，但清晰的理解其底层技术和假设是相当重要的。

​	有三种不同的方式来备份postgresql数据。

​	sql dump

​	file system level backup

​	continuous archiving and point-in-time recovery (pitr)

​	每一种都有优势和不足；我们在下面的环节讨论这些问题

## sql dump

​	sql dump 的思想是创建一个由SQL命令组成的文件，当把这个文件回馈给服务器时，服务器将利用其中的SQL命令重建与dump状态一样的数据库。postgresql为此提供了工具pg_dump。这个工具的基本用法是:

```
pg_dump dbname > dbname_bak.sql
```

​	pg_dump把结果输出到标准输出。尽管上述命令会创建一个文本文件,pg_dump可以用其他格式创建文件以支持并行和细粒度的对象恢复控制

​	pg_dump是一个普通的postgresql客户端应用。这意味着你可以在任何可以访问该数据库的远端主机上进行备份工作。

​	pg_dump不会以任何特殊权限运行。具体说来，就是它必须有你想要备份的表的读权限，因此为了备份整个数据库你几乎总是必须以一个数据库超级用户来运行它

​	和其他postgresql客户端应用一样，pg_dump默认使用与当前操作系统用户名同名的数据库用户名连接。要使用其他名字，要么声明-U选项，要么设置环境变量PGUSER,请注意pg_dump的连接也要通过客户认证机制

​	pg_dump对于其他备份方法的一个重要优势是，pg_dump的输出可以很容易的在新版本的postgresql中载入，而文件备份和连续归档都是限定的服务器和数据库。pg_dump是唯一可以将一个数据库传送到一个不同机器架构的方法。例如从一个32位服务器到一个64位服务器

​	由pg_dump创建的备份在内部是一致的，也就是说，dump表现了pg_dump开始运行时刻的数据库快照，且在pg_dump运行过程中发生的更新将不会dump，pg_dump工作的时候并不会阻塞其他对数据库的操作(但是会阻塞那些需要排它锁的操作，如alter table)	

### restoring the dump

​	pg_dump生成的文本文件可以由psql程序读取。从dump恢复的常用命令是:

```
psql dbname < infile
```

​	其中infile就是pg_dump命令的输出文件。这条命令不会创建数据库dbname,必须在执行psql前自己从template0创建,psql支持类似pg_dump的选项用以指定要连接的数据库服务器和要使用的用户名。参阅psql的手册获取更多信息。非文本文件dump可以使用pg_restore工具来恢复

​	在开始恢复之前，dump库中对象的拥有者以及在其上被授予了权限的用户必须已经存在，如果它们不存在，那么恢复过程将无法将对象创建成具有原来的所属关系以及权限

​	默认情况下，psql脚本在遇到一个sql错误后会继续执行，如果希望在遇到一个sql错误后让psql退出，那么可以设置ON_ERROR_STOP变量来运行psql,这将使psql在遇到sql错误后退出并返回状态3

```
psql --set ON_ERROR_STOP=on dbname <infile
```

​	不管怎样，你将只能得到一个部分恢复的数据库。作为另一种选择，你可以指定让整个恢复作为一个单独的事务运行，这样恢复要么完全完成要么完全回滚。这种模式可以通过向psql传递-1或`--single-transaction`命令选项来指定。在使用这种模式时，注意即使时很小的一个错误也会导致数小时的护肤被回滚。但是，这任然比在一个部分恢复后手工清理复杂的数据库更好。

​	pg_dump和psql读写管道的能力使得直接从一个服务器dump一个数据库到另外一个服务器成为可能。

```
pg_dump -h host1 dbname | psql -h host2 dbname
```

**pg_dump产生的dump是相对于tmplate0,这意味在template1中加入的任何语言，过程都会被pg_dump而dump。结果是，如果在恢复时使用的一个自定义的template1,必须从template0创建一个空的数据库**

​	一旦完成恢复，在每个数据库上运行`ANALYZE`是明智的举动，这样优化器就有有用的统计数据。

### using pg_dumpall

​	pg_dump每次只能dump一个数据库，而且不会dump关于角色或者表空间(因为它们是集簇范围的)信息，为了支持方便的dump一个数据库集簇的全部内容，提供`pg_dumpall`备份一个给定集簇中的每一个数据库，而且也保留了集簇范围的数据，如角色和表空间定义。该命令基本用法是

```
pg_dumpall > outfile
```

​	dump的结果可以使用psql恢复

```
psql -f infile postgres
```

​	实际上，你可以指定恢复到任何已有数据库名，但是如果你正在将dump载入到一个空集簇中则通常使用(postgresq)。在恢复一个pg_dump的dump常常需要具有数据库超级用户访问权限，因为它需要恢复角色和表空间信息。如果在使用表空间，请确保dump中的表空间路径适合新的安装

​	pg_dumpall工作时会发出命令会重新创建角色，表空间和数据库，接着为每一个数据库pg_dump。这意味者每个数据库自身是一致的，但是不同数据库的快照并不同步。

​	集簇范围的数据可以使用pd_dumpall的--global-only选项来单独dump，如果在单个数据库上运行pg_dump命令，上述做法对于完全备份整个集簇是必须的。



### Handling Large Databases

​	在一些具有最大文件尺寸限制的操作系统上创建大型的pg_dump输出文件可能会出现文件。幸运地是，pg_dup可以写出到标准输出，因此你可以使用标准Unix工具来处理这种潜在的问题。有几种的方法

1、使用压缩转储

​	这里可以使用喜欢的压缩程序，例如gzip

```
pg_dump dbname | gzip > filename.gz
```

恢复

```
gunzip -c filename.gz | psql dbname
```

2、使用split

​	split命令允许将输出分割为较小的文件以便能够适应底层文件系统的尺寸要求。例如，让每一块的大小为1M字节

```
pg_dump dbname | split -b 1m - filename
```

恢复

```
cat filename*|psql dbname
```

3、使用pg_dump的自定义存储格式

​	如果postgresql所在的系统上安装了zlib压缩裤，自定义dump格式将在写出数据到输出文件时对齐压缩。这将产生和使用gzip时差不多的dump文件，但是这种方式的一个优势是其中的表可以被有选择的恢复。下面的命令使用自定义dump格式来dump一个数据库

```
pg_dump -Fc dbname > filename
```

​	自定义格式的dump不是psql的脚本，只能通过pg_restore来恢复,例如

```
pg_restore -d dbname filename
```

​	详情参阅pg_dump和pg_restore

​	对于非常大型的数据库，你可能需要split配合其他两种方法之一进行使用。

4、使用pg_dump的并行dump特性

​	为了加快dump一个大型数据库的速度，可以使用pg_dump的并行模式。它将同时dump多个表，可以使用-j参数控制并行度。并行dump支持"目录"归档格式

```
pg_dump -j num -F d -f out.dir dbname
```

​	可以使用pg_restore -j 来以并行方式恢复一个dump,它只能适用于"自定义"归档或者"目录"归档，但不管归档是否有pg_dump -j创建。



## File System Level Backup

​	另外一种备份策略是直接复制postgresql用来存储数据库中的文件，可以选择喜欢的方式进行文件系统备份

```
tar -cf backup.tar /usr/local/pgsql/data
```

​	但是这种方法有两个限制，使用这种方法不实用，或者说至少比pg_dump方法差：

​	1、为了得到一个可用的备份，数据库服务器必须被关闭。

​	2、如果深入地了解数据库的文件系统布局的细节，可能会有兴趣尝试通过相应的文件或者目录来备份或者恢复特定的表或数据库。这种方法也不会起作用，因为包含在这些文件中的信息只有配合提交日志文件(pg_clog/*)才有用，提交日志文件包含了所有事务的提交状态。一个标文件只有和这些信息一起才有用。当然也不可能只恢复一个表和相关的pg_clog数据，因为这会导致数据库集簇所有其他表变得无用。因此文件系统只适合完整的备份或恢复整个数据库集簇。

​	另一种文件系统备份方法是创建一个数据目录的”一致快照“，如果文件系统支持此功能。典型的过程是创建以一个包含数据库的卷的”冻结快照“，然后从该快照复制整个数据目录(如上，不能是部分复制)到备份设备，最后释放冻结快照，即便在数据库服务器运行时，这种方式也有效。但是，以这种方式创建的备份保存看起来就像数据库没有被正确关闭的状态。因此，当你从备份数据上启动数据库服务器时，它会认为上一次服务器实例崩溃了并尝试重放WAL日志。这不是问题，只是需要注意(当然WAL文件必须要在备份中)。你可以在拍摄快照真会玩执行一次CHECKPOINT以便节省恢复时间

​	如果数据库跨越多个文件系统，当然没有任何方式对齐所有的卷获得完全同步的冻结快照。例如，数据文件和WAL放置在不同的磁盘上，或者表空间在不同的文件系统中，可能没有办法使用快照备份，因为快照必须是同步的。在这些情况下，一定要仔细阅读你的文件系统文档以了解其对一致快照技术的支持。

​	如果没有可能获得同步快照，一种选择是将数据库服务器关闭足够长的时间已建立所有的冻结快照，另外一种选择是执行一次连续归档基础备份。因为这种备份对于备份期间发生的文件系统的改变是免疫的。这要求在备份过程中允许连续归档，恢复时使用连续归档恢复。

​	还有一种选择是使用rsync来执行一次文件系统备份。其做法是现将数据库服务器运行时执行rsync,然后关闭数据库服务器足够长时间一次`rsync --checksum`（--checksum是必须的,因为rsync的文件修改时间颗粒度只能精确到秒)。第二次rsync会比第一次快，因为它只需要传送到相对很小的数据，由于服务器是挺一致的。这种方法允许在最小停机时间内执行一次文件系统备份

​	注意一个文件系统备份通常会比一个sqldump更大(例如pg_dump不需要dump索引的内容，而是dump用于重建索引的命令)。但是，做一个文件系统备份可能更快。



## Continuous Archiving and Point-in-Time Recovery (PITR)

​	在任何时间，postgresql在数据库集簇目录的pg_xlog/子目录下都保持一个预写式日志(WAL)。这个日志存在的目的是为了保证崩溃后的安全：如果系统崩溃，可以重放从最后一个检查点以来的日志项来恢复数据的一致性。该日志的存在也使得第三种备份数据库的策略变得可能：我们可以把一个文件系统级别的备份和WAL文件的备份结合起来。当需要恢复时。我们先恢复文件系统备份，然后从备份的WAL文件中重放来把系统带到一个当前状态。这种方法比之前的方法管理起来更复杂，但是有其显著的优点：

- ​	我们不需要一个完美的一致的文件系统作为开始点，备份中的任何内部不一致行将通过日志来修正。因此不需要文件系统快照功能，只需要一个tar或一个类似的归档工具

- ​         由于可以结合一个无穷长的wal文件序列用于重放，可以通过简单的归档来达到连续备份。这对于大型数据库特别有用，因为在其中不方便频繁地进行完全备份

- ​        并不需要一直重放WAL项一直到最后，可以在任何点停止重放，并得到一个数据库在当时的一致性快照。这样，该技术支持时间点恢复：在得到基础备份以后，可以将数据库恢复到它在其后任何时间的状态。

- ​        如果连续的将一些列的WAL文件输送到另一台已经载入了相同基础备份文件的机器，就得到一个热备份系统：在任何地点都能提出第二台机器，差不多就是数据库的当前副本

   **pg_dump和pg_dumpall不会产生文件系统级别的备份，并且不能用于连续归档方案，这类dump是逻辑的并且不包含足够的信息用于WAL重放**

   ​	就简单的文件系统备份技术来说，这种方法只能支持整个数据库集簇的回复，却无法支持其中一个子集的恢复。另外，它需要大量的归档存储；一个基础备份的体积可能很庞大，并且一个繁忙的系统将会产生大量需要被归档的WAL流量。尽管如此，在很多需要高可靠性的情况下，它是首选的备份技术。

   ​	要使用连续归档(也被很多数据库厂商称为“在线备份”)成功的恢复，需要一个从基础备份时间开始的连续归档WAL文件序列。为了开始，在建立第一个基础备份之前，应该建立并测试用于归档WAL文件的过程。对应地，首先讨论归档WAL文件的机制

   

### Setting Up WAL Archiving

​	抽象的说，一个运行中的POSTGRSQL系统产生一个无穷长的WAL记录序列。系统从物理上将这个序列划分为WAL段文件，通常是每个16MB(大小在构建POSTGRESQL时修改)。段文件会被分配一个数字名称以便反映它在整个抽象WAL序列中的位置。在没有使用WAL归档时，系统通常只会创建少量段文件，并且通过重命名不在使用的段文件为更高的段编号来回收它们。系统假设内容位于最后一个检查点之前的段文件时无用的且可以被回收

​	在归档WAL数据时，需要在每一段被填充满时捕捉器内容，并且在段文件被回收重用之前保存该数据。依靠应用和可用可用的硬件，有很多不同的方法来“保存数据”：可以将段文件拷贝到一个已挂载的位于另一台机器的NFS目录，或者将它们写到一个磁带驱动器(确保你有办法表示每个文件的原始文件名)，或者将它们批量烧录到CD上，或者其他什么方法。为了向数据库管理员提供灵活性，postgresql不对任何归档做任何假设。取而代之的是,postgresql让管理员声明一个shell命令来拷贝一个完整的段文件到它需要去的地方。该命令可以简单的就是一个cp,或者可以调用一个复杂的shell脚本

​	要启用WAL归档，需设置wal_level配置参数为replica或更好，设置archive_mode为on,并且使用archive_command配置参数指定一个shell命令。实际上，这些设置总是被放置在postgresql.conf文件中。在archive_command中，%p会被将要归档的文件路径所替代，而%f只会被文件名所替代(路径名是相对与当前工作目录而言，即集簇的数据目录)。如果你需要在命令中嵌入一个真正的%字符，可以使用%%，最简单的命令类似于:

```
archive_command = 'test ! -f /mnt/server/archivedir/%f && cp %p /mnt/server/archivedir/%f'  # Unix
archive_command = 'copy "%p" "C:\\server\\archivedir\\%f"'  # Windows
```

​	它将把WAL段拷贝到目录/mnt/server/archivedir（这个只是一个例子，并非建议的方法，可能不能在所有系统上都正确运行)。在%p和%f参数被替换之后，它实际被执行的命令看起来可能是

```
test ! -f /mnt/server/archivedir/00000001000000A900000065 && cp pg_xlog/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065
```

​	对每一个将要归档的新文件都会生成一个类似的命令

​	归档命令将在运行postgresql服务器的同一个用户的权限下执行。因为被归档的一系列WAL文件实际上包含数据库里的所有东西，所以确保自己的归档数据不被别人窥探；比如，归档到一个没有组或则全局读权限的目录里。

​	有一点很重要：当且仅当归档命令成功时，它才返回零退出。在得到一个零值结果之后，postgresql将假设该文件已经成功归档，因此它稍后将被删除或者被新的数据覆盖。但是，一个非零值告诉postgresql该文件没有被归档；因此它会周期性的重试知道成功。

​	归档命令通常应该被设计成拒绝覆盖已经存在的归档文件。这个一个非常重要的安全特性，可以在管理员操作失误(比如把两个不同服务器的输出发送到同一个归档目录)的时候保持归档的完整性。

​	建议将准备使用到归档命令测试，以保证它实际上不会覆盖现有的问题，**并且在这种情况下他返回非零状态**。以上Unix中的命令例子通过包含一个独立的test步骤来保证这一点。在某些Unix平台上，cp具有诸如-i的开关，可用来更简洁的完成一切，但是在没有验证返回的退出状态正确之前你不能依赖它们

​	在设计归档环境时，请考虑一下如果归档命令不停失败会发生什么情况，因为有些情况要求操作者的干涉，或者归档空间不够了，例如，让磁盘机上写，但是没有自动换带机，那么就有可能发生这种情况；如果磁带满了，除非换磁带，否则任何事务也做不了。你应该确保任何错误情况或者任何要求操作是干涉的情况都会被正确报告，这样才能迅速解决这些问题，否则pg_xlog目录会不停地被WAL段文件填充，直到问题解决(如果包含pg_xlog的文件系统被填满，postgresql将会做一次致命关闭。不会有未提交事务被丢失，但是数据库将会保持离线知道释放一部分空间)

​	归档命令的速度并不要紧，只要它能跟上服务器生成WAL数据的平均速度即可。即使归档进程稍微落后，正常的操作也会继续进行。如果归档进程慢很多，就会增加灾难发生的时候丢失的数据量。这同时也意味着pg_xlog目录包含大量未归档的段文件，并且可能最后超出了可用磁盘空间。建议监控归档进程。确保它是按照你的期望运转的。

​	在写自己的归档命令的时候，你应该假设被归档的文件名最长为64个字符并且可以包含ASCII字母、数字以及点的任意组合。我们不需要保持原始的相对路径(%p),但是有必要保持文件名(%f)

​	请注意尽管WAL归档允许恢复任何对postgresql数据库中数据所在的修改，但它不会赴会对配置文件的修改(即postgresql.conf,pg_hba.conf和pg_ident.conf),因为这些文件都是手工编辑的，而不是通过sql操作来编辑的。索引可能会需要吧配置文件放在一个日常文件系统备份过程可处理的位置。

​	归档命令只会为完成的WAL段调用。因此如果服务器产生了一点点WAL流量(或者在产生时有宽松的周期)，从一个事务完成到它被安全地记录在归档存储中之间将会有较长的延迟。要为未归档数据设置一个年龄限制，可以设置archive_timeout来强制要求服务器按照其设定的频度切换到一个新的WAL段。注意由于强制切换而被归档的文件还是具有和完全归档的文件相同的长度。因此设置一个很短的archive_timeout是很不明智的-它会膨胀归档存储。将archive_timeout设置1分钟左右通常合理的。

​	同样，如果希望确保一个刚刚完成的事务能被尽快归档，可以使用pg_switch_xlog进行一次手动段切换。

​	当wal_level为minimal时，一些sql命令被优化为避免WAL日志。在这些语句的其中之一的执行过程中如果打开了归档或流复制，WAL中将不会包含足够的信息用于归档恢复(崩溃恢复不受影响)。出于这个原因，wal_level只能在服务器启动时修改。但是,archive_command可以通过重载配置文件来修改。如果希望暂时停止归档，一种方式是将archive_command设置为空串('')。这将导致WAL文件积累在pg_xlog中，知道一个可用的archive_command被重新建立。

### Making a Base Backup

​	执行一个基础备份最简单的方法是使用pg_basebackup工具。它将会以普通文件或一个tar归档的方式创建一个基础备份。如果需要比pg_basebackup更高的灵活性，也可以使用低级API来制作一个基础备份。

​	没有必要关心创建一个基础备份所需的时间。但是如果正常的运行停用了full_page_writes的服务器，可能会注意到备份运行时性能下降，因为full_page_write在备份模式期间会被实际强制实施。

​	要使用被备份，需要保留所有文件系统备份期间及之后生成的WAL段文件，

